Disassembly Listing for MOD-I2C-GPIO-BL
Generated From:
/home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO.X/dist/XC8_PIC16LF18324/production/MOD-I2C-GPIO.X.production.elf
May 7, 2019 3:12:16 PM
/home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO-BL.X/dist/XC8_PIC16LF18324/production/MOD-I2C-GPIO-BL.X.production.elf
May 7, 2019 3:12:17 PM

---  /opt/microchip/xc8/v2.00/pic/sources/c90/pic/__eeprom.c  -------------------------------------------
1:             #include	<xc.h>	
2:             
3:             #if 	EEPROM_SIZE > 0
4:             
5:             void
6:             __eecpymem(volatile unsigned char *to, __eeprom unsigned char * from, unsigned char size)
04C1  00C8     MOVWF s1
7:             {
8:             	volatile unsigned char *cp = to;
04C2  0848     MOVF s1, W
04C3  00C7     MOVWF data
9:             #if _EEPROM_INT == _EEREG_INT
10:            	while (EECON1bits.WR) continue;
11:            	EEADR = (unsigned char)from;
12:            	while(size--) {
13:            		while (EECON1bits.WR) continue;
14:            		#ifdef	__FLASHTYPE
15:            		EECON1 &= 0x7F;
16:            		#endif
17:            		EECON1bits.RD = 1;
18:            		*cp++ = EEDATA;
19:            		++EEADR;
20:            	}
21:            #elif _EEPROM_INT == _NVMREG_INT
22:            	while (NVMCON1bits.WR) {
23:            		continue;
24:            	}
04C4  0031     MOVLB 0x11
04C5  1895     BTFSC NVMCON1, 0x1
04C6  2CC4     GOTO 0x4C4
25:            	NVMCON1bits.NVMREGS = 1;
04C7  1715     BSF NVMCON1, 0x6
26:            	NVMADRL = (unsigned char) from;
04C8  0020     MOVLB 0x0
04C9  0845     MOVF __pcstackBANK0, W
04CA  0031     MOVLB 0x11
04CB  0091     MOVWF NVMADR
27:            	NVMADRH = 0x70;
04CC  3070     MOVLW 0x70
04CD  0092     MOVWF NVMADRH
28:            	while (size--) {
04CE  0020     MOVLB 0x0
04CF  03C6     DECF n, F
04D0  0F46     INCFSZ n, W
04D1  2CD3     GOTO 0x4D3
04D2  0008     RETURN
04E0  2CCE     GOTO 0x4CE
29:            		NVMCON1bits.RD = 1;
04D3  0031     MOVLB 0x11
04D4  1415     BSF NVMCON1, 0x0
30:            		*cp++ = NVMDATL;
04D5  0020     MOVLB 0x0
04D6  0847     MOVF data, W
04D7  0086     MOVWF FSR1
04D8  0187     CLRF FSR1H
04D9  0031     MOVLB 0x11
04DA  0813     MOVF NVMDAT, W
04DB  0081     MOVWF 0x881
04DC  0020     MOVLB 0x0
04DD  0AC7     INCF data, F
31:            		NVMADRL++;
04DE  0031     MOVLB 0x11
04DF  0A91     INCF NVMADR, F
04E0  2CCE     GOTO 0x4CE
32:            	}
33:            #else
34:            #error "Unknonwn EEPROM register interface"
35:            #endif
36:            }
37:            
38:            void
39:            __memcpyee(__eeprom unsigned char * to, const unsigned char *from, unsigned char size)
40:            {
41:            	const unsigned char *ptr =from;
42:            #if _EEPROM_INT == _EEREG_INT
43:            	while (EECON1bits.WR) continue;
44:            	EEADR = (unsigned char)to - 1U;
45:            	#ifdef	__FLASHTYPE
46:            	EECON1 &= 0x7F;
47:            	#endif
48:            	while(size--) {
49:            		while (EECON1bits.WR) { 
50:            			continue;
51:            		}
52:            		EEDATA = *ptr++;
53:            		++EEADR;
54:            		STATUSbits.CARRY = 0; 
55:            		if (INTCONbits.GIE) {
56:            			STATUSbits.CARRY = 1; 
57:            		}
58:            		INTCONbits.GIE = 0;
59:            		EECON1bits.WREN = 1;
60:            		EECON2 = 0x55;
61:            		EECON2 = 0xAA;
62:            		EECON1bits.WR = 1;
63:            		EECON1bits.WREN = 0;
64:            		if (STATUSbits.CARRY) {
65:            			INTCONbits.GIE = 1;	//an opportunity for interrupts to happen
66:            		}
67:            	}
68:            #elif _EEPROM_INT == _NVMREG_INT
69:            	while (NVMCON1bits.WR) {
70:            		continue;
71:            	}
72:            	NVMCON1bits.NVMREGS = 1;
73:            	NVMADRL = (unsigned char) to - 1;
74:            	NVMADRH = 0x70;
75:            	NVMDATH = 0;
76:            	while (size--) {
77:            		while (NVMCON1bits.WR) {
78:            			continue;
79:            		}
80:            		NVMDATL = *ptr++;
81:            		NVMADRL++;
82:            		STATUSbits.CARRY = 0;
83:            		if (INTCONbits.GIE) {
84:            			STATUSbits.CARRY = 1;
85:            		}
86:            		NVMCON1bits.WREN = 1;
87:            		NVMCON2 = 0x55;
88:            		NVMCON2 = 0xAA;
89:            		NVMCON1bits.WR = 1;
90:            		while (NVMCON1bits.WR) {
91:            			continue;
92:            		}
93:            		NVMCON1bits.WREN = 0;
94:            		if (STATUSbits.CARRY) {
95:            			INTCONbits.GIE = 1;
96:            		}
97:            	}
98:            #else
99:            #error "Unknonwn EEPROM register interface"
100:           #endif
101:           }
102:           
103:           unsigned char
104:           __eetoc(__eeprom void *addr)
105:           {
106:           	unsigned char data;
107:           	__eecpymem((unsigned char *) &data,addr,1);
108:           	return data;
109:           }
110:           
111:           unsigned int
112:           __eetoi(__eeprom void *addr)
113:           {
114:           	unsigned int data;
115:           	__eecpymem((unsigned char *) &data,addr,2);
116:           	return data;
117:           }
118:           
119:           #pragma warning push
120:           #pragma warning disable 2040
121:           __uint24
122:           __eetom(__eeprom void *addr)
123:           {
124:           	__uint24 data;
125:           	__eecpymem((unsigned char *) &data,addr,3);
126:           	return data;
127:           }
128:           #pragma warning pop
129:           
130:           unsigned long
131:           __eetol(__eeprom void *addr)
044F  00CE     MOVWF 0x8CE
132:           {
133:           	unsigned long data;
134:           	__eecpymem((unsigned char *) &data,addr,4);
0450  00C5     MOVWF 0x8C5
0451  3004     MOVLW 0x4
0452  00C6     MOVWF 0x8C6
0453  304F     MOVLW 0x4F
0454  24C1     CALL 0x4C1
135:           	return data;
0455  0852     MOVF 0x8D2, W
0456  00CC     MOVWF 0x8CC
0457  0851     MOVF 0x8D1, W
0458  00CB     MOVWF 0x8CB
0459  0850     MOVF 0x8D0, W
045A  00CA     MOVWF 0x8CA
045B  084F     MOVF 0x8CF, W
045C  00C9     MOVWF 0x8C9
136:           }
045D  0008     RETURN
137:           
138:           #pragma warning push
139:           #pragma warning disable 1516
140:           unsigned long long
141:           __eetoo(__eeprom void *addr)
142:           {
143:           	unsigned long long data;
144:           	__eecpymem((unsigned char *) &data,addr,8);
145:           	return data;
146:           }
147:           #pragma warning pop
148:           
149:           unsigned char
150:           __ctoee(__eeprom void *addr, unsigned char data)
151:           {
152:           	__memcpyee(addr,(unsigned char *) &data,1);
153:           	return data;
154:           }
155:           
156:           unsigned int
157:           __itoee(__eeprom void *addr, unsigned int data)
158:           {
159:           	__memcpyee(addr,(unsigned char *) &data,2);
160:           	return data;
161:           }
162:           
163:           #pragma warning push
164:           #pragma warning disable 2040
165:           __uint24
166:           __mtoee(__eeprom void *addr, __uint24 data)
167:           {
168:           	__memcpyee(addr,(unsigned char *) &data,3);
169:           	return data;
170:           }
171:           #pragma warning pop
172:           
173:           unsigned long
174:           __ltoee(__eeprom void *addr, unsigned long data)
175:           {
176:           	__memcpyee(addr,(unsigned char *) &data,4);
177:           	return data;
178:           }
179:           
180:           #pragma warning push
181:           #pragma warning disable 1516
182:           unsigned long long
183:           __otoee(__eeprom void *addr, unsigned long long data)
184:           {
185:           	__memcpyee(addr,(unsigned char *) &data,8);
186:           	return data;
187:           }
188:           #pragma warning pop
189:           
190:           float
191:           __eetoft(__eeprom void *addr)
192:           {
193:           	float data;
194:           	__eecpymem((unsigned char *) &data,addr,3);
195:           	return data;
196:           }
197:           
198:           double
199:           __eetofl(__eeprom void *addr)
200:           {
201:           	double data;
202:           	__eecpymem((unsigned char *) &data,addr,4);
203:           	return data;
204:           }
205:           
206:           float
207:           __fttoee(__eeprom void *addr, float data)
208:           {
209:           	__memcpyee(addr,(unsigned char *) &data,3);
210:           	return data;
211:           }
212:           
213:           double
214:           __fltoee(__eeprom void *addr, double data)
215:           {
216:           	__memcpyee(addr,(unsigned char *) &data,4);
217:           	return data;
218:           }
219:           #endif
---  /opt/microchip/xc8/v2.00/pic/sources/c90/common/memcmp.c  ------------------------------------------
1:             #include	<string.h>
2:             
3:             memcmp(const void *s1, const void *s2, size_t n)
045E  00C8     MOVWF 0x8C8
4:             {
5:             	while(n-- != 0)  {
045F  3001     MOVLW 0x1
0460  02C6     SUBWF 0x8C6, F
0461  3000     MOVLW 0x0
0462  3BC7     SUBWFB 0x8C7, F
0463  0F46     INCFSZ 0x8C6, W
0464  2C68     GOTO 0x468
0465  0A47     INCF 0x8C7, W
0466  1903     BTFSC 0x883, 0x2
0467  2C80     GOTO 0x480
047F  2C5F     GOTO 0x45F
6:             		if(*((const unsigned char *)s1) != *((const unsigned char *)s2))
0468  0845     MOVF 0x8C5, W
0469  0086     MOVWF 0x886
046A  0187     CLRF 0x887
046B  0848     MOVF 0x8C8, W
046C  0084     MOVWF 0x884
046D  0185     CLRF 0x885
046E  0800     MOVF 0x880, W
046F  0601     XORWF 0x881, W
0470  1903     BTFSC 0x883, 0x2
0471  2C7D     GOTO 0x47D
7:             			return *((const unsigned char *)s1) - *((const unsigned char *)s2);
0472  0848     MOVF 0x8C8, W
0473  0086     MOVWF 0x886
0474  0845     MOVF 0x8C5, W
0475  0084     MOVWF 0x884
0476  0800     MOVF 0x880, W
0477  0201     SUBWF 0x881, W
0478  00C5     MOVWF 0x8C5
0479  01C6     CLRF 0x8C6
047A  1C03     BTFSS 0x883, 0x0
047B  03C6     DECF 0x8C6, F
047C  0008     RETURN
8:             		(*(const unsigned char **)&s1)++;
047D  0AC8     INCF 0x8C8, F
9:             		(*(const unsigned char **)&s2)++;
047E  0AC5     INCF 0x8C5, F
10:            	}
11:            	return 0;
0480  01C5     CLRF 0x8C5
0481  01C6     CLRF 0x8C6
12:            }
0482  0008     RETURN
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO.X/user.c  ---------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>         /* For uint8_t definition */
12:            #include <stdbool.h>        /* For true/false definition */
13:            #include <pic16lf18324.h>        
14:            
15:            #include "user.h"
16:            #include "registers.h"
17:            
18:            /******************************************************************************/
19:            /* User Functions                                                             */
20:            /******************************************************************************/
21:            
22:            static void __InitGPIO(void);
23:            static void __InitMSSP(void);
24:            static void __InitUnused(void);
25:            static void __InitInterrupts(void);
26:            
27:            
28:            
29:            /**
30:             * @brief Translate regmap to register
31:             * 
32:             * @param reg   Pointer to SFR
33:             * @param data  Pointer to regmap
34:             * 
35:             * The algorithm is:
36:             *  1.  The input data is e.g: 0xAB.
37:             *      The upper four bit are for PORTC and the lower 4 for PORTA.
38:             * 
39:             *  2.  Bytes for PORTA are padded to match pin register:
40:             *      | x | x | x | x | 3 | 2 | 1 | 0 |
41:             *      ---------------------------------
42:             *      | x | x | x | 3 | x | 2 | 1 | 0 |
43:             * 
44:             *  3.  Current direction is XORed with the new value. Then only bits with
45:             *      change are cleared.
46:             *      | x | x | x | 1 | x | 1 | 0 | 0 |   -> original value
47:             *      | x | x | x | 1 | x | 0 | 1 | 0 |   -> desired value
48:             *      ---------------------------------   
49:             *      | x | x | x | 0 | x | 1 | 1 | 0 |   -> XOR
50:             *      ---------------------------------
51:             *      | x | x | x | 1 | x | 0 | 0 | 1 |   -> NOT
52:             * 
53:             *      | x | x | x | 1 | x | 1 | 0 | 0 |   -> original value
54:             *      | x | x | x | 1 | x | 0 | 0 | 1 |   -> NOT value
55:             *      ---------------------------------   
56:             *      | x | x | x | 1 | x | 0 | 0 | 0 |   -> AND
57:             * 
58:             *  4.  Finally cleared value is OR-ed with the desired one"
59:             *      | x | x | x | 1 | x | 0 | 0 | 0 |   -> AND value
60:             *      | x | x | x | 1 | x | 0 | 1 | 0 |   -> desired value
61:             *      --------------------------------
62:             *      | x | x | x | 1 | x | 0 | 1 | 0 |   -> final value
63:             * 
64:             * This is a bit complicated, but this way we can guarantee that direction
65:             * will not toggle if there is no change in direction register.
66:             */
67:            static void __SetRegister(volatile unsigned char *reg, uint8_t *data)
68:            {
69:                volatile unsigned char *reg2;
70:                uint8_t sfr[2];
71:                uint8_t temp;
72:                
73:                /* Configure SFR */
74:                sfr[0] = *reg;
03E5  0845     MOVF 0x8C5, W
03E6  0086     MOVWF 0x886
03E7  0846     MOVF 0x8C6, W
03E8  0087     MOVWF 0x887
03E9  0801     MOVF 0x881, W
03EA  00CB     MOVWF 0x8CB
75:                temp = (uint8_t)((*data & 0x07) | ((*data & 0x08) << 1));
03EB  0847     MOVF 0x8C7, W
03EC  0086     MOVWF 0x886
03ED  0187     CLRF 0x887
03EE  0801     MOVF 0x881, W
03EF  3908     ANDLW 0x8
03F0  00C8     MOVWF 0x8C8
03F1  35C8     LSLF 0x8C8, F
03F2  0847     MOVF 0x8C7, W
03F3  0086     MOVWF 0x886
03F4  0801     MOVF 0x881, W
03F5  3907     ANDLW 0x7
03F6  0448     IORWF 0x8C8, W
03F7  00CD     MOVWF 0x8CD
76:                sfr[0] &= (uint8_t)(~((sfr[0] ^ temp) & 0x17));
03F8  064B     XORWF 0x8CB, W
03F9  3917     ANDLW 0x17
03FA  3AFF     XORLW 0xFF
03FB  05CB     ANDWF 0x8CB, F
77:                sfr[0] |= temp;
03FC  084D     MOVF 0x8CD, W
03FD  04CB     IORWF 0x8CB, F
78:                
79:                /* Configure SFR + 2 */
80:                reg2 = reg + 2;
03FE  0846     MOVF 0x8C6, W
03FF  00CA     MOVWF 0x8CA
0400  0845     MOVF 0x8C5, W
0401  00C9     MOVWF 0x8C9
0402  3002     MOVLW 0x2
0403  07C9     ADDWF 0x8C9, F
0404  1803     BTFSC 0x883, 0x0
0405  0ACA     INCF 0x8CA, F
81:                sfr[1] = *reg2;
0406  0849     MOVF 0x8C9, W
0407  0086     MOVWF 0x886
0408  084A     MOVF 0x8CA, W
0409  0087     MOVWF 0x887
040A  0801     MOVF 0x881, W
040B  00CC     MOVWF 0x8CC
82:                temp = (uint8_t)((*data & 0xF0) >> 2);
040C  0847     MOVF 0x8C7, W
040D  0086     MOVWF 0x886
040E  0187     CLRF 0x887
040F  0801     MOVF 0x881, W
0410  00C8     MOVWF 0x8C8
0411  36C8     LSRF 0x8C8, F
0412  36C8     LSRF 0x8C8, F
0413  0848     MOVF 0x8C8, W
0414  00CD     MOVWF 0x8CD
0415  303C     MOVLW 0x3C
0416  05CD     ANDWF 0x8CD, F
83:                
84:                sfr[1] &= (uint8_t)(~((sfr[1] ^ temp) & 0x3C));
0417  084C     MOVF 0x8CC, W
0418  064D     XORWF 0x8CD, W
0419  393C     ANDLW 0x3C
041A  3AFF     XORLW 0xFF
041B  05CC     ANDWF 0x8CC, F
85:                sfr[1] |= temp;
041C  084D     MOVF 0x8CD, W
041D  04CC     IORWF 0x8CC, F
86:                
87:                *reg = sfr[0];
041E  0845     MOVF 0x8C5, W
041F  0086     MOVWF 0x886
0420  0846     MOVF 0x8C6, W
0421  0087     MOVWF 0x887
0422  084B     MOVF 0x8CB, W
0423  0081     MOVWF 0x881
88:                *reg2 = sfr[1];
0424  084C     MOVF 0x8CC, W
0425  00C8     MOVWF 0x8C8
0426  0849     MOVF 0x8C9, W
0427  0086     MOVWF 0x886
0428  084A     MOVF 0x8CA, W
0429  0087     MOVWF 0x887
042A  0848     MOVF 0x8C8, W
042B  0081     MOVWF 0x881
89:            }
042C  0008     RETURN
90:            
91:            /**
92:             * @brief Translate SFR -> regmap
93:             * 
94:             * @param reg   Pointer to SFR register
95:             * @param data  Pointer to remap
96:             */
97:            static void __GetRegister(volatile uint8_t *reg, uint8_t *data)
98:            {
99:                uint8_t temp;
100:               
101:               /* Read PORTA */
102:               temp = (uint8_t)((*reg & 0x07) | ((*reg & 0x10) >> 1));
0489  0845     MOVF 0x8C5, W
048A  0086     MOVWF 0x886
048B  0846     MOVF 0x8C6, W
048C  0087     MOVWF 0x887
048D  0801     MOVF 0x881, W
048E  00C8     MOVWF 0x8C8
048F  3008     MOVLW 0x8
0490  36C8     LSRF 0x8C8, F
0491  0548     ANDWF 0x8C8, W
0492  00C9     MOVWF 0x8C9
0493  0845     MOVF 0x8C5, W
0494  0086     MOVWF 0x886
0495  0846     MOVF 0x8C6, W
0496  0087     MOVWF 0x887
0497  0801     MOVF 0x881, W
0498  3907     ANDLW 0x7
0499  0449     IORWF 0x8C9, W
049A  00CA     MOVWF 0x8CA
103:               
104:               /* Read PORTC */
105:               temp |= (uint8_t)((*reg & 0x3C) << 2);
049B  0845     MOVF 0x8C5, W
049C  0086     MOVWF 0x886
049D  0846     MOVF 0x8C6, W
049E  0087     MOVWF 0x887
049F  0801     MOVF 0x881, W
04A0  393C     ANDLW 0x3C
04A1  0709     ADDWF 0x889, W
04A2  0709     ADDWF 0x889, W
04A3  04CA     IORWF 0x8CA, F
106:               
107:               *data = temp;
04A4  0847     MOVF 0x8C7, W
04A5  0086     MOVWF 0x886
04A6  0187     CLRF 0x887
04A7  084A     MOVF 0x8CA, W
04A8  0081     MOVWF 0x881
108:           }
04A9  0008     RETURN
109:           
110:           
111:           void InitApp(void)
112:           {
113:               __InitGPIO();
043B  2325     CALL 0x325
043C  3183     MOVLP 0x3
114:               __InitMSSP();
043D  2442     CALL 0x442
043E  3183     MOVLP 0x3
115:               __InitUnused();
043F  24B5     CALL 0x4B5
0440  3183     MOVLP 0x3
116:               __InitInterrupts();
0441  2CAA     GOTO 0x4AA
117:           }
118:           
119:           /**
120:            * @brief Initialize GPIO
121:            * 
122:            * Setup GPIO as follows:
123:            *  - Analog functionality is disabled
124:            *  - RC0 and RC1 as I2C functions
125:            *  - RA5 open-drain output
126:            *  - All other pins as I/O
127:            */
128:           static void __InitGPIO(void)
129:           {
130:               /* Disable analog functions */
131:               ANSELA = 0x00;
0325  0023     MOVLB 0x3
0326  018C     CLRF ANSELA
132:               ANSELC = 0x00;
0327  018E     CLRF ANSELC
133:               
134:               /* Configure PPS function */
135:               RC0PPS = 0x18;
0328  3018     MOVLW 0x18
0329  003D     MOVLB 0x1D
032A  00A0     MOVWF RC0PPS
136:               RC1PPS = 0x19;
032B  3019     MOVLW 0x19
032C  00A1     MOVWF RC1PPS
137:               
138:               
139:               /* Configure direction */
140:               TRISAbits.TRISA5 = 0;
032D  0021     MOVLB 0x1
032E  128C     BCF TRISA, 0x5
141:           
142:           #if 0
143:               /* Make OD */
144:               ODCONAbits.ODCA5 = 1;
145:           #endif
146:               
147:               /* Configure value */
148:               INT_DEASSERT();
032F  0022     MOVLB 0x2
0330  168C     BSF LATA, 0x5
149:           
150:               SetGPIODirection();
0331  23D0     CALL 0x3D0
0332  3183     MOVLP 0x3
151:               SetGPIOOutput();
0333  23DE     CALL 0x3DE
0334  3183     MOVLP 0x3
152:               SetGPIOMode();
0335  23D7     CALL 0x3D7
0336  3183     MOVLP 0x3
153:               
154:               
155:               SetGPIOPullUp();
0337  242D     CALL 0x42D
0338  3183     MOVLP 0x3
156:               SetGPIOBuffer();    
0339  23C9     CALL 0x3C9
033A  3183     MOVLP 0x3
157:               SetGPIOSlew();
033B  2434     CALL 0x434
033C  3183     MOVLP 0x3
158:               
159:               GetGPIOInput();
033D  2483     CALL 0x483
160:               
161:               /* Enable IOC on both edges */
162:               IOCAP = 0x17;
033E  3017     MOVLW 0x17
033F  0027     MOVLB 0x7
0340  0091     MOVWF IOCAP
163:               IOCAN = 0x17;
0341  0092     MOVWF IOCAN
164:               IOCAF = 0;
0342  0193     CLRF IOCAF
165:               
166:               IOCCP = 0x3C;
0343  303C     MOVLW 0x3C
0344  0097     MOVWF IOCCP
167:               IOCCN = 0x3C;
0345  0098     MOVWF IOCCN
168:               IOCCF = 0;
0346  0199     CLRF IOCCF
169:               
170:           }
0347  0008     RETURN
171:           
172:           /**
173:            * @brief Initialize (disable) unused peripheries
174:            * 
175:            */
176:           static void __InitUnused(void)
177:           {
178:               PMD0 = 0x7A;
04B5  307A     MOVLW 0x7A
04B6  0032     MOVLB 0x12
04B7  0091     MOVWF PMD0
179:               PMD1 = 0xFF;
04B8  30FF     MOVLW 0xFF
04B9  0092     MOVWF PMD1
180:               PMD2 = 0xFF;
04BA  0093     MOVWF PMD2
181:               PMD3 = 0xFF;
04BB  0094     MOVWF PMD3
182:               PMD4 = 0xFD;
04BC  30FD     MOVLW 0xFD
04BD  0095     MOVWF PMD4
183:               PMD5 = 0xFF;
04BE  30FF     MOVLW 0xFF
04BF  0096     MOVWF PMD5
184:           }
04C0  0008     RETURN
185:           
186:           /**
187:            * @brief Initialize I2C controller
188:            * 
189:            * Initialize MSSP as I2C slave device. It should be capable of 400kHz
190:            * operation.
191:            * 
192:            * @see I2C_SLAVE_ADDRESS
193:            */
194:           static void __InitMSSP(void)
195:           {
196:               /**
197:                * Configure SSP1 STATUS REGISTER as follows:
198:                *  - SMP: SPI Data Input Sample bit
199:                *      0 = slew rate control enabled for High-Speed mode (400 kHz)
200:                *  - CKE: SPI Clock Edge Select bit
201:                *      1 = Enable input logic so that thresholds are compliant with SMBus specification
202:                */
203:               SSP1STAT = 0x40;
0442  3040     MOVLW 0x40
0443  0024     MOVLB 0x4
0444  0094     MOVWF SSP1STAT
204:               
205:               /**
206:                * Configure SSP1CON1: SSP1 CONTROL REGISTER 1 as follows:
207:                *  - WCOL: Write Collision Detect bit (Transmit mode only)
208:                *      0 = No collision
209:                *  - SSPOV: Receive Overflow Indicator bit
210:                *      0 = No overflow
211:                *  - SSPEN: Synchronous Serial Port Enable bit
212:                *      1 = Enables the serial port and configures the SDA and SCL pins as the source of the serial port pins
213:                *  - CKP: Clock Polarity Select bit
214:                *      1 = Enable clock
215:                *  - SSPM: Synchronous Serial Port Mode Select bits
216:                *      0110 = I2C Slave mode, 7-bit address
217:                */
218:               SSP1CON1 = 0x36;
0445  3036     MOVLW 0x36
0446  0095     MOVWF SSP1CON1
219:               
220:               /**
221:                * Configure SSP1CON2: SSP1 CONTROL REGISTER 2 as follows:
222:                *  - GCEN: General Call Enable bit
223:                *      0 = General call address disabled
224:                *  - SEN: Start Condition Enable/Stretch Enable bit
225:                *      1 = Clock stretching is enabled for both slave transmit and slave receive (stretch enabled)
226:                */
227:               SSP1CON2 = 0x01;
0447  3001     MOVLW 0x1
0448  0096     MOVWF SSP1CON2
228:               
229:               /**
230:                * Configure SSP1CON3: SSP1 CONTROL REGISTER 3 as follows:
231:                *  - PCIE: Stop Condition Interrupt Enable bit
232:                *      0 = Stop detection interrupts are disabled
233:                *  - SCIE: Start Condition Interrupt Enable bit
234:                *      0 = Start detection interrupts are disabled
235:                *  - BOEN: Buffer Overwrite Enable bit
236:                *      0 = SSPBUF is only updated when SSPOV is clear
237:                *  - SDAHT: SDA Hold Time Selection bit
238:                *      0 = Minimum of 100 ns hold time on SDA after the falling edge of SCL
239:                *  - SBCDE: Slave Mode Bus Collision Detect Enable bit
240:                *      0 = Slave bus collision interrupts are disabled
241:                *  - AHEN: Address Hold Enable bit
242:                *      0 = Address holding is disabled
243:                *  - DHEN: Data Hold Enable bit
244:                *      0 = Data holding is disabled
245:                */
246:               SSP1CON3 = 0x00;
0449  0197     CLRF SSP1CON3
247:               
248:               /* Set ADDRESS and MASK */
249:               SSP1MSK = (I2C_SLAVE_MASK << 1);
044A  30FE     MOVLW 0xFE
044B  0093     MOVWF SSP1MSK
250:               SSP1ADD = (I2C_SLAVE_ADDRESS << 1);    
044C  3076     MOVLW 0x76
044D  0092     MOVWF SSP1ADD
251:               
252:           }
044E  0008     RETURN
253:           
254:           /**
255:            * @brief Configure interrupts
256:            * 
257:            * Enable individual peripheral interrupts.
258:            */
259:           static void __InitInterrupts(void)
260:           {
261:               /* Enable MSSP interrupts */
262:               PIR1bits.SSP1IF = 0;
04AA  0020     MOVLB 0x0
04AB  1191     BCF PIR1, 0x3
263:               PIE1bits.SSP1IE = 1;
04AC  0021     MOVLB 0x1
04AD  1591     BSF PIE1, 0x3
264:               
265:               /* Enable IOC interrupts */
266:               PIR0bits.IOCIF = 0;
04AE  0020     MOVLB 0x0
04AF  1210     BCF PIR0, 0x4
267:               PIE0bits.IOCIE = 1;
04B0  0021     MOVLB 0x1
04B1  1610     BSF PIE0, 0x4
268:               
269:               /* Enable Peripheral interrupts */
270:               INTCONbits.PEIE = 1;
04B2  170B     BSF 0x8B, 0x6
271:               
272:               /* Enable Global interrupts */
273:               INTCONbits.GIE = 1;
04B3  178B     BSF 0x8B, 0x7
274:               
275:           }
04B4  0008     RETURN
276:           
277:           /**
278:            * @brief Set pin direction
279:            * 
280:            * Set direction of GPIO0 to GPIO7. Data is read from the global resister,
281:            * so this should be called only when there is change in it.
282:            * Pin direction is changed only if needed.
283:            * 
284:            */
285:           void SetGPIODirection(void)
286:           {    
287:               __SetRegister(&TRISA, &regmap.dir);
03D0  308C     MOVLW 0x8C
03D1  0020     MOVLB 0x0
03D2  00C5     MOVWF __pcstackBANK0
03D3  303A     MOVLW 0x3A
03D4  01C6     CLRF n
03D5  00C7     MOVWF data
03D6  2BE5     GOTO 0x3E5
288:           }
289:           
290:           /**
291:            * @brief Set output pin value
292:            * 
293:            * Set value of the pins configured as outputs. Values are read from the
294:            * global register, so this should be called only when there is change in it.
295:            * If pin is configured as input, this function do nothing.
296:            * @see SetGPIODirection
297:            */
298:           void SetGPIOOutput(void)
299:           {
300:               __SetRegister(&LATA, &regmap.output);
03DE  300C     MOVLW 0xC
03DF  00C5     MOVWF __pcstackBANK0
03E0  3001     MOVLW 0x1
03E1  00C6     MOVWF n
03E2  303C     MOVLW 0x3C
03E3  00C7     MOVWF data
03E4  2BE5     GOTO 0x3E5
301:           }
302:           
303:           /**
304:            * @brief Read input pins
305:            * 
306:            * Read current value of the pins configured as inputs and stores them into
307:            * the global register.
308:            */
309:           void GetGPIOInput(void)
310:           {
311:               __GetRegister(&PORTA, &regmap.input);
0483  300C     MOVLW 0xC
0484  00C5     MOVWF __pcstackBANK0
0485  303B     MOVLW 0x3B
0486  01C6     CLRF n
0487  00C7     MOVWF data
0488  2C89     GOTO 0x489
312:           }
313:           
314:           /**
315:            * @brief Sets pull-ups
316:            * 
317:            * Enable/disable internal weak pull-ups. If pins is configured as output
318:            * setting this value has no effect, except for OD configuration.
319:            */
320:           void SetGPIOPullUp(void)
321:           {
322:               __SetRegister(&WPUA, &regmap.pullup);
042D  300C     MOVLW 0xC
042E  00C5     MOVWF __pcstackBANK0
042F  3002     MOVLW 0x2
0430  00C6     MOVWF n
0431  303D     MOVLW 0x3D
0432  00C7     MOVWF data
0433  2BE5     GOTO 0x3E5
323:           }
324:           
325:           /**
326:            * @brief Enabled open-drain configuration
327:            * 
328:            * Enable/disable open-drain output configuration.
329:            */
330:           void SetGPIOMode(void)
331:           {
332:               __SetRegister(&ODCONA, &regmap.mode);
03D7  308C     MOVLW 0x8C
03D8  00C5     MOVWF __pcstackBANK0
03D9  3002     MOVLW 0x2
03DA  00C6     MOVWF n
03DB  303E     MOVLW 0x3E
03DC  00C7     MOVWF data
03DD  2BE5     GOTO 0x3E5
333:           }
334:           
335:           /**
336:            * @brief Select CMOS/TTL input level
337:            * 
338:            */
339:           void SetGPIOBuffer(void)
340:           {
341:               __SetRegister(&INLVLA, &regmap.buffer);
03C9  308C     MOVLW 0x8C
03CA  00C5     MOVWF __pcstackBANK0
03CB  3003     MOVLW 0x3
03CC  00C6     MOVWF n
03CD  303F     MOVLW 0x3F
03CE  00C7     MOVWF data
03CF  2BE5     GOTO 0x3E5
342:           }
343:           
344:           /**
345:            * @brief Select input slew rate
346:            * 
347:            * Limit or allow maximum slew rate.
348:            */
349:           void SetGPIOSlew(void)
350:           {
351:               __SetRegister(&SLRCONA, &regmap.buffer);
0434  300C     MOVLW 0xC
0435  00C5     MOVWF __pcstackBANK0
0436  3003     MOVLW 0x3
0437  00C6     MOVWF n
0438  303F     MOVLW 0x3F
0439  00C7     MOVWF data
043A  2BE5     GOTO 0x3E5
352:           }
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO.X/system.c  -------------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>        /* For uint8_t definition */
12:            #include <stdbool.h>       /* For true/false definition */
13:            
14:            #include "system.h"
15:            
16:            void ConfigureOscillator(void)
17:            {
18:                // NOSC HFINTOSC with 2x PLL; NDIV 1; 
19:                OSCCON1 = 0x00;
03BE  0032     MOVLB 0x12
03BF  0199     CLRF OSCCON1
20:                
21:                // CSWHOLD may proceed; SOSCPWR Low power; SOSCBE crystal oscillator; 
22:                OSCCON3 = 0x00;
03C0  019B     CLRF OSCCON3
23:                
24:                // LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
25:                OSCEN = 0x00;
03C1  019D     CLRF OSCEN
26:                
27:                // HFFRQ 16_MHz; 
28:                OSCFRQ = 0x06;
03C2  3006     MOVLW 0x6
03C3  009F     MOVWF OSCFRQ
29:                
30:                // HFTUN 32; 
31:                OSCTUNE = 0x20;
03C4  3020     MOVLW 0x20
03C5  009E     MOVWF OSCTUNE
32:                
33:                // Wait for PLL to stabilize
34:                while(PLLR == 0)
35:                {
36:                }
03C6  181C     BTFSC OSCSTAT1, 0x0
03C7  0008     RETURN
03C8  2BC6     GOTO 0x3C6
37:            }
0204  147E     BSF 0x97E, 0x0
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO.X/main.c  ---------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>        /* For uint8_t definition */
12:            #include <stdbool.h>       /* For true/false definition */
13:            #include <string.h>
14:            
15:            #include "registers.h"
16:            #include "system.h"        /* System funct/params, like osc/peripheral config */
17:            #include "user.h"          /* User funct/params, such as InitApp */
18:            
19:            /******************************************************************************/
20:            /* User Global Variable Declaration                                           */
21:            /******************************************************************************/
22:            
23:            /**
24:             * @brief Make pointers.
25:             * 
26:             * A pointer used for I2C communication. On each read/write address will
27:             * increase. If requested register is outside regmap, the pointer will 
28:             * retrun dummy byte.
29:             */
30:            struct registers regmap, current_regmap;
31:            
32:            uint8_t *pointer = (uint8_t *)&regmap;
0318  3033     MOVLW 0x33
33:            
34:            eeprom uint32_t serial = 0x12345678;
35:            enum RequestType req;
36:            
37:            
38:            /******************************************************************************/
39:            /* Main Program                                                               */
40:            /******************************************************************************/
41:            void main(void)
42:            {
43:            
44:            #ifndef XPRJ_SIMULATOR
45:                /* Configure the oscillator for the device */
46:                ConfigureOscillator();
0348  23BE     CALL 0x3BE
0349  3183     MOVLP 0x3
47:            #endif
48:            
49:                /* Configure default values */
50:                regmap.device = DEVICE_ID;
034A  3043     MOVLW 0x43
034B  0020     MOVLB 0x0
034C  00B3     MOVWF regmap
51:                regmap.firmware = FIRMWARE_VERSION;
034E  01B4     CLRF 0x34
034F  0AB4     INCF 0x34, F
52:                regmap.serial = serial;
034D  3000     MOVLW 0x0
0350  244F     CALL 0x44F
0351  3183     MOVLP 0x3
0352  084C     MOVF 0x4C, W
0353  00B8     MOVWF 0x38
0354  084B     MOVF sfr, W
0355  00B7     MOVWF 0x37
0356  084A     MOVF temp, W
0357  00B6     MOVWF 0x36
0358  0849     MOVF reg2, W
0359  00B5     MOVWF 0x35
53:                regmap.function = 0x00;                 /* All GPIOs */
035B  01B9     CLRF 0x39
54:                regmap.dir = 0xFF;                      /* All inputs */
035A  30FF     MOVLW 0xFF
035C  00BA     MOVWF 0x3A
55:                regmap.input = 0x00;                    /* Input */
035D  01BB     CLRF 0x3B
56:                regmap.output = 0x00;                   /* Output */
035E  01BC     CLRF 0x3C
57:                regmap.pullup = 0xFF;                   /* All pull-ups enabled */
035F  00BD     MOVWF 0x3D
58:                regmap.mode = 0x00;                     /* All push-pull mode */
0360  01BE     CLRF 0x3E
59:                regmap.buffer = 0xFF;                   /* All ST enabled inputs */
0361  00BF     MOVWF 0x3F
60:                regmap.slew = 0xFF;                     /* Slew rate is limited */
0362  00C0     MOVWF 0x40
61:             
62:                regmap.interrupt_enable = 0x00;         /* All interrupts are disabled */
0363  01C1     CLRF 0x41
63:                regmap.interrupt_sense = 0x0000;
0364  01C2     CLRF 0x42
0365  01C3     CLRF 0x43
64:                regmap.interrupt_status = 0x00;
0366  01C4     CLRF 0x44
65:            
66:                /* Initialize I/O and Peripherals for application */
67:                InitApp();    
0367  243B     CALL 0x43B
0368  3183     MOVLP 0x3
68:                
69:                /* Copy default values to current settings */
70:                memcpy(&current_regmap, &regmap, sizeof(struct registers));
0369  3033     MOVLW 0x33
036A  0084     MOVWF FSR0
036B  3012     MOVLW 0x12
036C  0185     CLRF FSR0H
036D  0020     MOVLB 0x0
036E  00D3     MOVWF 0x53
036F  0853     MOVF 0x53, W
0370  1903     BTFSC STATUS, 0x2
0371  2B7A     GOTO 0x37A
0372  3021     MOVLW 0x21
0373  0086     MOVWF FSR1
0374  0187     CLRF FSR1H
0375  0012     MOVIW FSR0++
0376  001E     MOVWI FSR1++
0377  0020     MOVLB 0x0
0378  0BD3     DECFSZ 0x53, F
0379  2B75     GOTO 0x375
71:            
72:                while(1)
73:                {
74:                    /* Check for change in registers */
75:                    if(memcmp(&regmap, &current_regmap, sizeof(struct registers))) {
037A  3021     MOVLW 0x21
037B  0020     MOVLB 0x0
037C  00C5     MOVWF __pcstackBANK0
037D  3012     MOVLW 0x12
037E  00C6     MOVWF n
037F  3033     MOVLW 0x33
0380  01C7     CLRF data
0381  245E     CALL 0x45E
0382  3183     MOVLP 0x3
0383  0845     MOVF __pcstackBANK0, W
0384  0446     IORWF n, W
0385  1903     BTFSC STATUS, 0x2
0386  2BBC     GOTO 0x3BC
76:                        
77:                        /* Interrupts must be disabled during pins setting */          
78:            //            INTCONbits.GIE = 0;
79:                        /* Disabled SSPI interrupts */
80:                        PIE1bits.SSP1IE = 0;
0387  0021     MOVLB 0x1
0388  1191     BCF PIE1, 0x3
81:                        
82:                        /* Check for direction changes */
83:                        if(regmap.dir != current_regmap.dir) {
0389  0020     MOVLB 0x0
038A  083A     MOVF 0x3A, W
038B  0628     XORWF 0x28, W
038C  1903     BTFSC STATUS, 0x2
038D  2B92     GOTO 0x392
84:                            SetGPIODirection();
038E  23D0     CALL 0x3D0
038F  3183     MOVLP 0x3
85:                            current_regmap.dir = regmap.dir;
0390  083A     MOVF 0x3A, W
0391  00A8     MOVWF 0x28
86:                        }
87:                        
88:                        if(regmap.output != current_regmap.output) {
0392  083C     MOVF 0x3C, W
0393  062A     XORWF 0x2A, W
0394  1903     BTFSC STATUS, 0x2
0395  2B9A     GOTO 0x39A
89:                            SetGPIOOutput();
0396  23DE     CALL 0x3DE
0397  3183     MOVLP 0x3
90:                            current_regmap.output = regmap.output;
0398  083C     MOVF 0x3C, W
0399  00AA     MOVWF 0x2A
91:                        }
92:                        
93:                        if(regmap.pullup != current_regmap.pullup) {
039A  083D     MOVF 0x3D, W
039B  062B     XORWF 0x2B, W
039C  1903     BTFSC STATUS, 0x2
039D  2BA2     GOTO 0x3A2
94:                            SetGPIOPullUp();
039E  242D     CALL 0x42D
039F  3183     MOVLP 0x3
95:                            current_regmap.pullup = regmap.pullup;
03A0  083D     MOVF 0x3D, W
03A1  00AB     MOVWF 0x2B
96:                        }
97:                        
98:                        if(regmap.mode != current_regmap.mode) {
03A2  083E     MOVF 0x3E, W
03A3  062C     XORWF 0x2C, W
03A4  1903     BTFSC STATUS, 0x2
03A5  2BAA     GOTO 0x3AA
99:                            SetGPIOMode();
03A6  23D7     CALL 0x3D7
03A7  3183     MOVLP 0x3
100:                           current_regmap.mode = regmap.mode;
03A8  083E     MOVF 0x3E, W
03A9  00AC     MOVWF 0x2C
101:                       }
102:                       
103:                       if(regmap.buffer != current_regmap.buffer) {
03AA  083F     MOVF 0x3F, W
03AB  062D     XORWF 0x2D, W
03AC  1903     BTFSC STATUS, 0x2
03AD  2BB2     GOTO 0x3B2
104:                           SetGPIOBuffer();
03AE  23C9     CALL 0x3C9
03AF  3183     MOVLP 0x3
105:                           current_regmap.buffer = regmap.buffer;
03B0  083F     MOVF 0x3F, W
03B1  00AD     MOVWF 0x2D
106:                       }
107:                       
108:                       if(regmap.slew != current_regmap.slew) {
03B2  0840     MOVF 0x40, W
03B3  062E     XORWF 0x2E, W
03B4  1903     BTFSC STATUS, 0x2
03B5  2BBA     GOTO 0x3BA
109:                           SetGPIOSlew();
03B6  2434     CALL 0x434
03B7  3183     MOVLP 0x3
110:                           current_regmap.slew = regmap.slew;
03B8  0840     MOVF 0x40, W
03B9  00AE     MOVWF 0x2E
111:                       }            
112:                        
113:                       PIE1bits.SSP1IE = 1;
03BA  0021     MOVLB 0x1
03BB  1591     BSF PIE1, 0x3
114:           //             INTCONbits.GIE = 1;
115:                   }
116:                   
117:                   CLRWDT();
03BC  0064     CLRWDT
03BD  2B7A     GOTO 0x37A
118:               }
119:           
120:           }
121:           
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO.X/interrupts.c  ---------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>         /* For uint8_t definition */
12:            #include <stdbool.h>        /* For true/false definition */
13:            #include <pic16lf18324.h>
14:            
15:            #include "registers.h"
16:            #include "user.h"
17:            
18:            /******************************************************************************/
19:            /* Interrupt Routines                                                         */
20:            /******************************************************************************/
21:            
22:            static inline void __MSSPInterrupt(void);
23:            static inline void __IOCInterrupt(void);
24:            
25:            void interrupt isr(void)
0204  147E     BSF 0xFE, 0x0
0205  3182     MOVLP 0x2
26:            {
27:                if(PIR1bits.SSP1IF)
0206  0020     MOVLB 0x0
0207  1D91     BTFSS PIR1, 0x3
0208  2A6A     GOTO 0x26A
28:                    __MSSPInterrupt();
29:                else if(PIR0bits.IOCIF)
026A  1E10     BTFSS PIR0, 0x4
026B  2A68     GOTO 0x268
30:                    __IOCInterrupt();
31:            }
0268  107E     BCF 0x7E, 0x0
0269  0009     RETFIE
32:            
33:            static inline void __IOCInterrupt(void)
34:            {
35:                volatile uint8_t ioca;
36:                volatile uint8_t iocc;
37:                volatile uint8_t data;
38:                volatile uint8_t ioc;
39:                volatile uint8_t mask;
40:                volatile uint8_t i;    
41:                
42:                /* Store current interrupt flags */
43:                ioca = IOCAF;
026C  0027     MOVLB 0x7
026D  0813     MOVF IOCAF, W
026E  00F7     MOVWF 0x3F7
44:                iocc = IOCCF;
026F  0819     MOVF IOCCF, W
0270  00F6     MOVWF 0x3F6
45:                
46:                /* Clear IOC flags */
47:                IOCAF &= (uint8_t)(~(ioca));
0271  0977     COMF 0x3F7, W
0272  0593     ANDWF IOCAF, F
48:                IOCCF &= (uint8_t)(~(iocc));
0273  0976     COMF 0x3F6, W
0274  0599     ANDWF IOCCF, F
49:                PIR0bits.IOCIF = 0;
0275  0020     MOVLB 0x0
0276  1210     BCF PIR0, 0x4
50:                
51:                /* Read pin inputs */
52:                data = (uint8_t)((PORTA & 0x07) | ((PORTA & 0x10) >> 1));
0277  080C     MOVF PORTA, W
0278  00F0     MOVWF __pcstackCOMMON
0279  3008     MOVLW 0x8
027A  36F0     LSRF __pcstackCOMMON, F
027B  0570     ANDWF __pcstackCOMMON, W
027C  00F1     MOVWF 0x71
027D  080C     MOVF PORTA, W
027E  3907     ANDLW 0x7
027F  0471     IORWF 0x71, W
0280  00F4     MOVWF 0x74
53:                data |= (uint8_t)((PORTC & 0x3C) << 2);
0281  080E     MOVF PORTC, W
0282  393C     ANDLW 0x3C
0283  0709     ADDWF WREG, W
0284  0709     ADDWF WREG, W
0285  04F4     IORWF 0x74, F
54:                
55:                /* Mask data */
56:                regmap.input = data;
0286  0874     MOVF 0x74, W
0287  00BB     MOVWF 0x3B
57:                
58:                /* Map IOCxF to regmap */
59:                ioc = (uint8_t)((ioca & 0x07) | ((ioca & 0x10) >> 1));
0288  0877     MOVF 0x77, W
0289  00F0     MOVWF __pcstackCOMMON
028A  3008     MOVLW 0x8
028B  36F0     LSRF __pcstackCOMMON, F
028C  0570     ANDWF __pcstackCOMMON, W
028D  00F1     MOVWF 0x71
028E  0877     MOVF 0x77, W
028F  3907     ANDLW 0x7
0290  0471     IORWF 0x71, W
0291  00F5     MOVWF 0x75
60:                ioc |= (uint8_t)((iocc & 0x3C) << 2);
0292  0876     MOVF 0x76, W
0293  393C     ANDLW 0x3C
0294  0709     ADDWF WREG, W
0295  0709     ADDWF WREG, W
0296  04F5     IORWF 0x75, F
61:                
62:                /* Check for INT request */
63:                mask = (uint8_t)(ioc & regmap.interrupt_enable);
0297  0841     MOVF 0x41, W
0298  00F8     MOVWF 0x78
0299  0875     MOVF 0x75, W
029A  05F8     ANDWF 0x78, F
64:                if (mask) {
029B  0878     MOVF 0x78, W
029C  1903     BTFSC STATUS, 0x2
029D  2A68     GOTO 0x268
029E  2AA0     GOTO 0x2A0
029F  2A68     GOTO 0x268
65:                    if (regmap.input & mask) {
02A0  083B     MOVF 0x3B, W
02A1  0578     ANDWF 0x78, W
02A2  1903     BTFSC STATUS, 0x2
02A3  2ADE     GOTO 0x2DE
02A4  2AA6     GOTO 0x2A6
02A5  2ADE     GOTO 0x2DE
66:                        
67:                        /**
68:                         * Rising edge
69:                         * Check if sense is correct
70:                         */
71:                        for (i = 0; i < 8; i++) {
02A6  01F9     CLRF 0x79
02A7  3008     MOVLW 0x8
02A8  0279     SUBWF 0x79, W
02A9  1C03     BTFSS STATUS, 0x0
02AA  2AAE     GOTO 0x2AE
02AB  2A68     GOTO 0x268
02AC  2AAE     GOTO 0x2AE
02AD  2A68     GOTO 0x268
02D6  3008     MOVLW 0x8
02D7  0AF9     INCF 0x79, F
02D8  0279     SUBWF 0x79, W
02D9  1C03     BTFSS STATUS, 0x0
02DA  2AAE     GOTO 0x2AE
02DB  2A68     GOTO 0x268
02DC  2AAE     GOTO 0x2AE
02DD  2A68     GOTO 0x268
72:                            if (mask & (1 << i)) {
02AE  3001     MOVLW 0x1
02AF  00F0     MOVWF __pcstackCOMMON
02B0  0A79     INCF 0x79, W
02B1  2AB3     GOTO 0x2B3
02B2  35F0     LSLF __pcstackCOMMON, F
02B3  0B89     DECFSZ WREG, F
02B4  2AB2     GOTO 0x2B2
02B5  0870     MOVF __pcstackCOMMON, W
02B6  0578     ANDWF 0x78, W
02B7  1903     BTFSC STATUS, 0x2
02B8  2AD6     GOTO 0x2D6
02B9  2ABB     GOTO 0x2BB
02BA  2AD6     GOTO 0x2D6
73:                                if (regmap.interrupt_sense & (uint16_t)((0x01 << i*2))) {
02BB  3001     MOVLW 0x1
02BC  00F0     MOVWF __pcstackCOMMON
02BD  3000     MOVLW 0x0
02BE  01F1     CLRF 0x71
02BF  3579     LSLF 0x79, W
02C0  0A89     INCF WREG, F
02C1  2AC4     GOTO 0x2C4
02C2  35F0     LSLF __pcstackCOMMON, F
02C3  0DF1     RLF 0x71, F
02C4  0B89     DECFSZ WREG, F
02C5  2AC2     GOTO 0x2C2
02C6  0020     MOVLB 0x0
02C7  0842     MOVF 0x42, W
02C8  0570     ANDWF __pcstackCOMMON, W
02C9  00F2     MOVWF 0x72
02CA  0843     MOVF 0x43, W
02CB  0571     ANDWF 0x71, W
02CC  00F3     MOVWF 0x73
02CD  0472     IORWF 0x72, W
02CE  1903     BTFSC STATUS, 0x2
02CF  2AD6     GOTO 0x2D6
02D0  2AD2     GOTO 0x2D2
02D1  2AD6     GOTO 0x2D6
74:                                    regmap.interrupt_status |= mask;
02D2  0878     MOVF 0x78, W
02D3  04C4     IORWF 0x44, F
75:                                    INT_ASSERT();
02D4  0022     MOVLB 0x2
02D5  128C     BCF LATA, 0x5
76:                                }
77:                            }
78:                        }
79:                        
80:                    } else {
81:                        
82:                        /**
83:                         * Falling edge
84:                         * Check if sense is correct
85:                         */
86:                        for(i = 0; i < 8; i++) {
02DE  01F9     CLRF 0x179
02DF  3008     MOVLW 0x8
02E0  0279     SUBWF 0x179, W
02E1  1C03     BTFSS 0x103, 0x0
02E2  2AE6     GOTO 0x2E6
02E3  2A68     GOTO 0x268
02E4  2AE6     GOTO 0x2E6
02E5  2A68     GOTO 0x268
030E  3008     MOVLW 0x8
87:                            if(mask & (1 << i)) {
02E6  3001     MOVLW 0x1
02E7  00F0     MOVWF 0x170
02E8  0A79     INCF 0x179, W
02E9  2AEB     GOTO 0x2EB
02EA  35F0     LSLF 0x170, F
02EB  0B89     DECFSZ 0x109, F
02EC  2AEA     GOTO 0x2EA
02ED  0870     MOVF 0x170, W
02EE  0578     ANDWF 0x178, W
02EF  1903     BTFSC 0x103, 0x2
02F0  2B0E     GOTO 0x30E
02F1  2AF3     GOTO 0x2F3
02F2  2B0E     GOTO 0x30E
88:                                if(regmap.interrupt_sense & (uint16_t)((0x02 << i*2))) {
02F3  3002     MOVLW 0x2
02F4  00F0     MOVWF 0x170
02F5  3000     MOVLW 0x0
02F6  01F1     CLRF 0x171
02F7  3579     LSLF 0x179, W
02F8  0A89     INCF 0x109, F
02F9  2AFC     GOTO 0x2FC
02FA  35F0     LSLF 0x170, F
02FB  0DF1     RLF 0x171, F
02FC  0B89     DECFSZ 0x109, F
02FD  2AFA     GOTO 0x2FA
02FE  0020     MOVLB 0x0
02FF  0842     MOVF 0x42, W
0300  0570     ANDWF __pcstackCOMMON, W
0301  00F2     MOVWF 0x72
0302  0843     MOVF 0x43, W
0303  0571     ANDWF 0x71, W
0304  00F3     MOVWF 0x73
0305  0472     IORWF 0x72, W
0306  1903     BTFSC STATUS, 0x2
0307  2B0E     GOTO 0x30E
0308  2B0A     GOTO 0x30A
0309  2B0E     GOTO 0x30E
89:                                    regmap.interrupt_status |= mask;
030A  0878     MOVF 0x78, W
030B  04C4     IORWF 0x44, F
90:                                    INT_ASSERT();
030C  0022     MOVLB 0x2
030D  128C     BCF LATA, 0x5
91:                                }
92:                            }                
93:                        }            
94:                    }
95:                }          
96:            }
97:            /**
98:             * @brief Handle MSSP interrupts
99:             */
100:           static inline void __MSSPInterrupt(void)
101:           {
102:               volatile uint8_t data;
103:               
104:               /* Clear interrupt flag */
105:               PIR1bits.SSP1IF = 0;
0209  1191     BCF CM1CON0, 0x3
106:               
107:               /* Clear BF */
108:               data = SSP1BUF;    
020A  0024     MOVLB 0x4
020B  0811     MOVF SSP1BUF, W
020C  00F0     MOVWF 0x270
109:               
110:               if(SSP1STATbits.R_nW) {
020D  1D14     BTFSS SSP1STAT, 0x2
020E  2A34     GOTO 0x234
020F  2A11     GOTO 0x211
0210  2A34     GOTO 0x234
111:                   /**
112:                    * We've got READ from MASTER
113:                    */
114:                   if((SSP1STATbits.D_nA) && (SSP1CON2bits.ACKSTAT)) {
0211  1E94     BTFSS SSP1STAT, 0x5
0212  2A24     GOTO 0x224
0213  2A15     GOTO 0x215
0214  2A24     GOTO 0x224
0215  1F16     BTFSS SSP1CON2, 0x6
0216  2A24     GOTO 0x224
0217  2A19     GOTO 0x219
0218  2A24     GOTO 0x224
115:                       if (pointer >= (uint8_t *)&regmap.interrupt_status)
0219  3044     MOVLW 0x44
021A  027A     SUBWF 0x27A, W
021B  1C03     BTFSS 0x203, 0x0
021C  2A22     GOTO 0x222
021D  2A1F     GOTO 0x21F
021E  2A22     GOTO 0x222
116:                           pointer = (uint8_t *)&regmap;
021F  3033     MOVLW 0x33
0220  00FA     MOVWF 0x27A
0221  2A66     GOTO 0x266
117:                       else
118:                           ++pointer;
0222  0AFA     INCF 0x27A, F
0223  2A66     GOTO 0x266
119:                   } else {
120:                       /* Got read request */
121:                       
122:                       SSPBUF = *pointer;
0224  087A     MOVF 0x27A, W
0225  0086     MOVWF 0x206
0226  0187     CLRF 0x207
0227  0801     MOVF 0x201, W
0228  0091     MOVWF SSP1BUF
123:                       
124:                       /* Clear pending INT on INTERRUPT_STATUS read */
125:                       if(pointer == (uint8_t *)&regmap.interrupt_status) {
0229  087A     MOVF 0x27A, W
022A  3A44     XORLW 0x44
022B  1D03     BTFSS 0x203, 0x2
022C  2A22     GOTO 0x222
022D  2A2F     GOTO 0x22F
022E  2A22     GOTO 0x222
126:                           regmap.interrupt_status = 0x00;
022F  0020     MOVLB 0x0
0230  01C4     CLRF 0x44
127:                           INT_DEASSERT();
0231  0022     MOVLB 0x2
0232  168C     BSF LATA, 0x5
0233  2A22     GOTO 0x222
128:                       }
129:                       
130:                       ++pointer;  
131:                   }
132:               } else if(!SSP1STATbits.D_nA) {
0234  1A94     BTFSC CM2CON1, 0x5
0235  2A3B     GOTO 0x23B
0236  2A38     GOTO 0x238
0237  2A3B     GOTO 0x23B
133:                   /**
134:                    * Got write request.
135:                    * Next will be registry address
136:                    */
137:                   req = I2C_NEXT_IS_ADDR;
0238  0020     MOVLB 0x0
0239  01A0     CLRF req
023A  2A66     GOTO 0x266
138:               } else {
139:                   /* Process data */
140:                   if(req == I2C_NEXT_IS_ADDR) {
023B  0020     MOVLB 0x0
023C  0820     MOVF req, W
023D  1D03     BTFSS STATUS, 0x2
023E  2A4C     GOTO 0x24C
023F  2A41     GOTO 0x241
0240  2A4C     GOTO 0x24C
141:                       if(data < sizeof(struct registers))
0241  3012     MOVLW 0x12
0242  0270     SUBWF __pcstackCOMMON, W
0243  1803     BTFSC STATUS, 0x0
0244  2A64     GOTO 0x264
0245  2A47     GOTO 0x247
0246  2A64     GOTO 0x264
142:                           pointer = (uint8_t *)&regmap + data;
0247  3033     MOVLW 0x33
0248  00FA     MOVWF pointer
0249  0870     MOVF __pcstackCOMMON, W
024A  07FA     ADDWF pointer, F
024B  2A64     GOTO 0x264
143:                   } else {
144:                       if(pointer >= &regmap.dir &&
145:                               pointer != &regmap.input &&
146:                               pointer != &regmap.interrupt_status)
024C  303A     MOVLW 0x3A
024D  027A     SUBWF pointer, W
024E  1C03     BTFSS STATUS, 0x0
024F  2A63     GOTO 0x263
0250  2A52     GOTO 0x252
0251  2A63     GOTO 0x263
0252  087A     MOVF pointer, W
0253  3A3B     XORLW 0x3B
0254  1903     BTFSC STATUS, 0x2
0255  2A63     GOTO 0x263
0256  2A58     GOTO 0x258
0257  2A63     GOTO 0x263
0258  087A     MOVF pointer, W
0259  3A44     XORLW 0x44
025A  1903     BTFSC STATUS, 0x2
025B  2A63     GOTO 0x263
025C  2A5E     GOTO 0x25E
025D  2A63     GOTO 0x263
147:                           *pointer = data;
025E  087A     MOVF pointer, W
025F  0086     MOVWF FSR1
0260  0187     CLRF FSR1H
0261  0870     MOVF __pcstackCOMMON, W
0262  0081     MOVWF INDF1
148:                       
149:                       ++pointer;
0263  0AFA     INCF pointer, F
150:                   }
151:                   
152:                   req = I2C_NEXT_IS_DATA;        
0264  01A0     CLRF req
0265  0AA0     INCF req, F
153:               }
154:           
155:               /* Release SCL */
156:               SSP1CON1bits.CKP = 1;    
0266  0024     MOVLB 0x4
0267  1615     BSF SSP1CON1, 0x4
0268  107E     BCF 0x27E, 0x0
0269  0009     RETFIE
026A  1E10     BTFSS 0x210, 0x4
026B  2A68     GOTO 0x268
026C  0027     MOVLB 0x7
026D  0813     MOVF IOCAF, W
026E  00F7     MOVWF 0x3F7
026F  0819     MOVF IOCCF, W
0270  00F6     MOVWF 0x3F6
0271  0977     COMF 0x3F7, W
0272  0593     ANDWF IOCAF, F
0273  0976     COMF 0x3F6, W
0274  0599     ANDWF IOCCF, F
0275  0020     MOVLB 0x0
0276  1210     BCF PIR0, 0x4
0277  080C     MOVF PORTA, W
0278  00F0     MOVWF __pcstackCOMMON
0279  3008     MOVLW 0x8
027A  36F0     LSRF __pcstackCOMMON, F
027B  0570     ANDWF __pcstackCOMMON, W
027C  00F1     MOVWF 0x71
027D  080C     MOVF PORTA, W
027E  3907     ANDLW 0x7
027F  0471     IORWF 0x71, W
0280  00F4     MOVWF 0x74
0281  080E     MOVF PORTC, W
0282  393C     ANDLW 0x3C
0283  0709     ADDWF WREG, W
0284  0709     ADDWF WREG, W
0285  04F4     IORWF 0x74, F
0286  0874     MOVF 0x74, W
0287  00BB     MOVWF 0x3B
0288  0877     MOVF 0x77, W
0289  00F0     MOVWF __pcstackCOMMON
028A  3008     MOVLW 0x8
028B  36F0     LSRF __pcstackCOMMON, F
028C  0570     ANDWF __pcstackCOMMON, W
028D  00F1     MOVWF 0x71
028E  0877     MOVF 0x77, W
028F  3907     ANDLW 0x7
0290  0471     IORWF 0x71, W
0291  00F5     MOVWF 0x75
0292  0876     MOVF 0x76, W
0293  393C     ANDLW 0x3C
0294  0709     ADDWF WREG, W
0295  0709     ADDWF WREG, W
0296  04F5     IORWF 0x75, F
0297  0841     MOVF 0x41, W
0298  00F8     MOVWF 0x78
0299  0875     MOVF 0x75, W
029A  05F8     ANDWF 0x78, F
029B  0878     MOVF 0x78, W
029C  1903     BTFSC STATUS, 0x2
029D  2A68     GOTO 0x268
029E  2AA0     GOTO 0x2A0
029F  2A68     GOTO 0x268
02A0  083B     MOVF 0x3B, W
02A1  0578     ANDWF 0x78, W
02A2  1903     BTFSC STATUS, 0x2
02A3  2ADE     GOTO 0x2DE
02A4  2AA6     GOTO 0x2A6
02A5  2ADE     GOTO 0x2DE
02A6  01F9     CLRF 0x79
02A7  3008     MOVLW 0x8
02A8  0279     SUBWF 0x79, W
02A9  1C03     BTFSS STATUS, 0x0
02AA  2AAE     GOTO 0x2AE
02AB  2A68     GOTO 0x268
02AC  2AAE     GOTO 0x2AE
02AD  2A68     GOTO 0x268
02AE  3001     MOVLW 0x1
02AF  00F0     MOVWF __pcstackCOMMON
02B0  0A79     INCF 0x79, W
02B1  2AB3     GOTO 0x2B3
02B2  35F0     LSLF __pcstackCOMMON, F
02B3  0B89     DECFSZ WREG, F
02B4  2AB2     GOTO 0x2B2
02B5  0870     MOVF __pcstackCOMMON, W
02B6  0578     ANDWF 0x78, W
02B7  1903     BTFSC STATUS, 0x2
02B8  2AD6     GOTO 0x2D6
02B9  2ABB     GOTO 0x2BB
02BA  2AD6     GOTO 0x2D6
02BB  3001     MOVLW 0x1
02BC  00F0     MOVWF __pcstackCOMMON
02BD  3000     MOVLW 0x0
02BE  01F1     CLRF 0x71
02BF  3579     LSLF 0x79, W
02C0  0A89     INCF WREG, F
02C1  2AC4     GOTO 0x2C4
02C2  35F0     LSLF __pcstackCOMMON, F
02C3  0DF1     RLF 0x71, F
02C4  0B89     DECFSZ WREG, F
02C5  2AC2     GOTO 0x2C2
02C6  0020     MOVLB 0x0
02C7  0842     MOVF 0x42, W
02C8  0570     ANDWF __pcstackCOMMON, W
02C9  00F2     MOVWF 0x72
02CA  0843     MOVF 0x43, W
02CB  0571     ANDWF 0x71, W
02CC  00F3     MOVWF 0x73
02CD  0472     IORWF 0x72, W
02CE  1903     BTFSC STATUS, 0x2
02CF  2AD6     GOTO 0x2D6
02D0  2AD2     GOTO 0x2D2
02D1  2AD6     GOTO 0x2D6
02D2  0878     MOVF 0x78, W
02D3  04C4     IORWF 0x44, F
02D4  0022     MOVLB 0x2
02D5  128C     BCF LATA, 0x5
02D6  3008     MOVLW 0x8
02D7  0AF9     INCF 0x179, F
02D8  0279     SUBWF 0x179, W
02D9  1C03     BTFSS 0x103, 0x0
02DA  2AAE     GOTO 0x2AE
02DB  2A68     GOTO 0x268
02DC  2AAE     GOTO 0x2AE
02DD  2A68     GOTO 0x268
02DE  01F9     CLRF 0x179
02DF  3008     MOVLW 0x8
02E0  0279     SUBWF 0x179, W
02E1  1C03     BTFSS 0x103, 0x0
02E2  2AE6     GOTO 0x2E6
02E3  2A68     GOTO 0x268
02E4  2AE6     GOTO 0x2E6
02E5  2A68     GOTO 0x268
02E6  3001     MOVLW 0x1
02E7  00F0     MOVWF 0x170
02E8  0A79     INCF 0x179, W
02E9  2AEB     GOTO 0x2EB
02EA  35F0     LSLF 0x170, F
02EB  0B89     DECFSZ 0x109, F
02EC  2AEA     GOTO 0x2EA
02ED  0870     MOVF 0x170, W
02EE  0578     ANDWF 0x178, W
02EF  1903     BTFSC 0x103, 0x2
02F0  2B0E     GOTO 0x30E
02F1  2AF3     GOTO 0x2F3
02F2  2B0E     GOTO 0x30E
02F3  3002     MOVLW 0x2
02F4  00F0     MOVWF 0x170
02F5  3000     MOVLW 0x0
02F6  01F1     CLRF 0x171
02F7  3579     LSLF 0x179, W
02F8  0A89     INCF 0x109, F
02F9  2AFC     GOTO 0x2FC
02FA  35F0     LSLF 0x170, F
02FB  0DF1     RLF 0x171, F
02FC  0B89     DECFSZ 0x109, F
02FD  2AFA     GOTO 0x2FA
02FE  0020     MOVLB 0x0
02FF  0842     MOVF 0x42, W
0300  0570     ANDWF __pcstackCOMMON, W
0301  00F2     MOVWF 0x72
0302  0843     MOVF 0x43, W
0303  0571     ANDWF 0x71, W
0304  00F3     MOVWF 0x73
0305  0472     IORWF 0x72, W
0306  1903     BTFSC STATUS, 0x2
0307  2B0E     GOTO 0x30E
0308  2B0A     GOTO 0x30A
0309  2B0E     GOTO 0x30E
030A  0878     MOVF 0x78, W
030B  04C4     IORWF 0x44, F
030C  0022     MOVLB 0x2
030D  128C     BCF LATA, 0x5
030E  3008     MOVLW 0x8
030F  0AF9     INCF 0x179, F
0310  0279     SUBWF 0x179, W
0311  1C03     BTFSS 0x103, 0x0
0312  2AE6     GOTO 0x2E6
0313  2A68     GOTO 0x268
0314  2AE6     GOTO 0x2E6
0315  2A68     GOTO 0x268
157:           }
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO-BL.X/user.c  ------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>         /* For uint8_t definition */
12:            #include <stdbool.h>        /* For true/false definition */
13:            
14:            #include "user.h"
15:            
16:            /******************************************************************************/
17:            /* User Functions                                                             */
18:            /******************************************************************************/
19:            
20:            /**
21:             * @brief Initialize I2C controller
22:             * 
23:             * Initialize MSSP as I2C slave device. It should be capable of 400kHz
24:             * operation.
25:             * 
26:             * @see I2C_SLAVE_ADDRESS
27:             */
28:            static void __InitMSSP(void)
29:            {
30:                /**
31:                 * Configure SSP1 STATUS REGISTER as follows:
32:                 *  - SMP: SPI Data Input Sample bit
33:                 *      0 = slew rate control enabled for High-Speed mode (400 kHz)
34:                 *  - CKE: SPI Clock Edge Select bit
35:                 *      1 = Enable input logic so that thresholds are compliant with SMBus specification
36:                 */
37:                SSP1STAT = 0x40;
002B  3040     MOVLW 0x40
002C  0024     MOVLB 0x4
002D  0094     MOVWF SSP1STAT
38:                
39:                /**
40:                 * Configure SSP1CON1: SSP1 CONTROL REGISTER 1 as follows:
41:                 *  - WCOL: Write Collision Detect bit (Transmit mode only)
42:                 *      0 = No collision
43:                 *  - SSPOV: Receive Overflow Indicator bit
44:                 *      0 = No overflow
45:                 *  - SSPEN: Synchronous Serial Port Enable bit
46:                 *      1 = Enables the serial port and configures the SDA and SCL pins as the source of the serial port pins
47:                 *  - CKP: Clock Polarity Select bit
48:                 *      1 = Enable clock
49:                 *  - SSPM: Synchronous Serial Port Mode Select bits
50:                 *      0110 = I2C Slave mode, 7-bit address
51:                 */
52:                SSP1CON1 = 0x36;
002E  3036     MOVLW 0x36
002F  0095     MOVWF SSP1CON1
53:                
54:                /**
55:                 * Configure SSP1CON2: SSP1 CONTROL REGISTER 2 as follows:
56:                 *  - GCEN: General Call Enable bit
57:                 *      0 = General call address disabled
58:                 *  - SEN: Start Condition Enable/Stretch Enable bit
59:                 *      1 = Clock stretching is enabled for both slave transmit and slave receive (stretch enabled)
60:                 */
61:                SSP1CON2 = 0x01;
0030  3001     MOVLW 0x1
0031  0096     MOVWF SSP1CON2
62:                
63:                /**
64:                 * Configure SSP1CON3: SSP1 CONTROL REGISTER 3 as follows:
65:                 *  - PCIE: Stop Condition Interrupt Enable bit
66:                 *      0 = Stop detection interrupts are disabled
67:                 *  - SCIE: Start Condition Interrupt Enable bit
68:                 *      0 = Start detection interrupts are disabled
69:                 *  - BOEN: Buffer Overwrite Enable bit
70:                 *      0 = SSPBUF is only updated when SSPOV is clear
71:                 *  - SDAHT: SDA Hold Time Selection bit
72:                 *      0 = Minimum of 100 ns hold time on SDA after the falling edge of SCL
73:                 *  - SBCDE: Slave Mode Bus Collision Detect Enable bit
74:                 *      0 = Slave bus collision interrupts are disabled
75:                 *  - AHEN: Address Hold Enable bit
76:                 *      0 = Address holding is disabled
77:                 *  - DHEN: Data Hold Enable bit
78:                 *      0 = Data holding is disabled
79:                 */
80:                SSP1CON3 = 0x00;
0032  0197     CLRF SSP1CON3
81:                
82:                /* Set ADDRESS and MASK */
83:                SSP1MSK = (I2C_SLAVE_MASK << 1);
0033  30FE     MOVLW 0xFE
0034  0093     MOVWF SSP1MSK
84:                SSP1ADD = (I2C_SLAVE_ADDRESS << 1);    
0035  3076     MOVLW 0x76
0036  0092     MOVWF SSP1ADD
85:                
86:            }
0037  0008     RETURN
87:            
88:            void InitApp(void)
89:            {
90:                /* Disable ANALOG function */
91:                ANSELA = 0;
0027  0023     MOVLB 0x3
0028  018C     CLRF ANSELA
92:                ANSELC = 0;
0029  018E     CLRF ANSELC
93:                
94:                __InitMSSP();
002A  282B     GOTO 0x2B
95:            
96:            }
97:            
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO-BL.X/system.c  ----------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>        /* For uint8_t definition */
12:            #include <stdbool.h>       /* For true/false definition */
13:            
14:            #include "system.h"
15:            
16:            void ConfigureOscillator(void)
17:            {
18:                // NOSC HFINTOSC with 2x PLL; NDIV 1; 
19:                OSCCON1 = 0x00;
001C  0032     MOVLB 0x12
001D  0199     CLRF OSCCON1
20:                
21:                // CSWHOLD may proceed; SOSCPWR Low power; SOSCBE crystal oscillator; 
22:                OSCCON3 = 0x00;
001E  019B     CLRF OSCCON3
23:                
24:                // LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
25:                OSCEN = 0x00;
001F  019D     CLRF OSCEN
26:                
27:                // HFFRQ 16_MHz; 
28:                OSCFRQ = 0x06;
0020  3006     MOVLW 0x6
0021  009F     MOVWF OSCFRQ
29:                
30:                // HFTUN 32; 
31:                OSCTUNE = 0x20;
0022  3020     MOVLW 0x20
0023  009E     MOVWF OSCTUNE
32:                
33:                // Wait for PLL to stabilize
34:                while(PLLR == 0)
35:                {
36:                }
0024  181C     BTFSC OSCSTAT1, 0x0
0025  0008     RETURN
0026  2824     GOTO 0x24
37:                
38:            }
0004  147E     BSF 0x97E, 0x0
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO-BL.X/main.c  ------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>        /* For uint8_t definition */
12:            #include <stdbool.h>
13:            #include <pic16lf18324.h>       /* For true/false definition */
14:            
15:            #include "system.h"        /* System funct/params, like osc/peripheral config */
16:            #include "user.h"          /* User funct/params, such as InitApp */
17:            
18:            /******************************************************************************/
19:            /* User Global Variable Declaration                                           */
20:            /******************************************************************************/
21:            
22:            enum commands {
23:                CMD_READ_VERSION = 0,
24:                CMD_READ_FLASH,
25:                CMD_WRITE_FLASH,
26:                CMD_ERASE_FLASH,
27:                CMD_READ_EE_DATA,
28:                CMD_WRITE_EE_DATA,
29:                CMD_READ_CONFIG,
30:                CMD_WRITE_CONFIG,
31:                CMD_CALC_CHECKSUM,
32:                CMD_RESET_DEVICE
33:            };
34:            
35:            /******************************************************************************/
36:            /* Main Program                                                               */
37:            /******************************************************************************/
38:            void main(void)
39:            {
40:                /* Configure the oscillator for the device */
41:                ConfigureOscillator();
000F  201C     CALL 0x1C
0010  3180     MOVLP 0x0
42:            
43:                /* Initialize I/O and Peripherals for application */
44:                InitApp();
0011  2027     CALL 0x27
0012  3180     MOVLP 0x0
45:                
46:                
47:                /* If RA5 is high load application */
48:                // TODO: Checksum must be also read
49:                
50:                if(PORTAbits.RA5) {
0013  0020     MOVLB 0x0
0014  1E8C     BTFSS PORTA, 0x5
0015  281B     GOTO 0x1B
51:                    
52:                    STKPTR = 0x1F;
0016  301F     MOVLW 0x1F
0017  003F     MOVLB 0x1F
0018  00ED     MOVWF STKPTR
53:                    asm ("pagesel 0x200");
0019  3182     MOVLP 0x2
54:                    asm ("goto 0x200");
001A  2A00     GOTO 0x200
55:                }
56:            
57:                while(1)
001B  281B     GOTO 0x1B
58:                {
59:                    
60:                }
61:            
62:            }
63:            
---  /home/stefan/MPLABXProjects/MOD-I2C-GPIO/Firmware/MOD-I2C-GPIO-BL.X/interrupts.c  ------------------
1:             /******************************************************************************/
2:             /*Files to Include                                                            */
3:             /******************************************************************************/
4:             
5:             #if defined(__XC)
6:                 #include <xc.h>         /* XC8 General Include File */
7:             #elif defined(HI_TECH_C)
8:                 #include <htc.h>        /* HiTech General Include File */
9:             #endif
10:            
11:            #include <stdint.h>         /* For uint8_t definition */
12:            #include <stdbool.h>        /* For true/false definition */
13:            
14:            /******************************************************************************/
15:            /* Interrupt Routines                                                         */
16:            /******************************************************************************/
17:            
18:            void interrupt isr(void)
0004  147E     BSF 0xFFE, 0x0
0005  3180     MOVLP 0x0
19:            {
20:                asm ("pagesel 0x204");
0006  3182     MOVLP 0x2
21:                asm ("goto 0x204");
0007  2A04     GOTO 0x204
22:            }
0008  107E     BCF 0xFFE, 0x0
0009  0009     RETFIE
23:            
24:            
25:            
